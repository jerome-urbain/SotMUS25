{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction <p>Welcome to the \"How to put an entire count(r)y in a container: transportable OSM data integration into Postgis\" hands-on session!</p> <p>We will explore the seamless integration of OpenStreetMap (OSM) data in PostGIS using the Imposm tool within a Dockerized environment. The workshop is structured to guide you through the entire process:</p> <ul> <li>Preparing your setup to learn Docker basics, </li> <li>Setting up a PostGIS database, </li> <li>Understanding Imposm's functionalities including <ul> <li>the mapping between OSM keywords and Postgresql table attributes </li> <li>the command to load medium to big OSM datasets into Postgis</li> <li>how to build a docker stack combining imposm and postgis</li> </ul> </li> <li>Interacting with the loaded OSM data with QGIS and SQL,</li> <li>Enhancing your Docker stack for improved performance. </li> </ul> <p>Whether you're a GIS enthusiast, developer, or data professional, this workshop provides a practical and comprehensive approach to harnessing the synergy between OSM, PostGIS, and Docker. </p> <p>The workshop was originally created by Benjamin Deswysen: https://bdeswysen.gitlab.io/sotm_workshop/00_intro.html</p> <p>Many thanks to him for doing all the heavy lifting here.</p> <p>It's been adapted by Jerome Urbain to be presented at State of the Map US 2025 in Boston.</p>","text":""},{"location":"01_setup/","title":"Setup <p>This workshop needs a specific setup based on docker.  Please follow the docker installation steps based on your OS (windows / linux / mac) to enjoy this workshop content!</p>    <pre><code>If you're running this locally and the images don't display, you may need to convert ../figures into ./figures in all the .md files.\n</code></pre> <p>You can install Docker Desktop OR Docker Engine depending on your preferences. If this is your first experience with docker or you're unsure, Docker Desktop is recommended.</p>","text":""},{"location":"01_setup/#docker-desktop","title":"Docker Desktop  <pre><code>WARNING: carefully follow the installation steps and prerequisites mentioned in the documentation, and do not skip any of them.\n</code></pre>","text":""},{"location":"01_setup/#windows","title":"Windows <p>Install Docker Desktop on Windows: https://docs.docker.com/desktop/install/windows-install/</p>","text":""},{"location":"01_setup/#linux","title":"Linux <p>Install Docker Desktop on Linux: https://docs.docker.com/desktop/install/linux-install/</p>","text":""},{"location":"01_setup/#mac-os","title":"Mac OS <p>Install Docker Desktop on Mac: https://docs.docker.com/desktop/install/mac-install/</p>","text":""},{"location":"01_setup/#docker-engine","title":"Docker Engine  <p>If your OS is linux, you can also use a regular <code>docker engine</code> setup and combine it with <code>docker compose</code> installed as plugin: - docker engine: https://docs.docker.com/engine/install/ - docker compose plugin [deprecated but still working]: https://docs.docker.com/compose/install/linux/#install-using-the-repository</p> <p>As docker compose V1 stopped receiving updates from July ZO23, it is recommended to use docker compose V2 or higher. (https://docs.docker.com/compose/)</p> <p>To check your installed docker compose version, you can run the following command in your terminal:</p> <pre><code>docker compose version\n</code></pre>","text":""},{"location":"01_setup/#clone-or-download-the-gitlab-repository","title":"Clone or download the gitlab repository  <p>This workshop is based on a public github repository: https://github.com/jerome-urbain/SotMUS25 .</p> <p>If you have git or git bash (Windows) installed, feel free to clone the workshop repository:</p> <pre><code>git clone https://github.com/jerome-urbain/SotMUS25.git\n</code></pre> <p>Otherwise, you can simply download it as zip file here:https://github.com/jerome-urbain/SotMUS25/archive/refs/heads/main.zip</p>","text":""},{"location":"02_docker/","title":"Docker survival kit <p>Below you'll find some commands and explanations for your docker survival kit at this workshop.</p> <p>If you're already a power user and familiar with these concepts, you can continue with the next chapter.</p> <p>If, on the other hand, you're a novice but still want to delve deeper into the concepts after this workshop, I urge you to take a look at the docker documentation: https://docs.docker.com/</p> <p>Let's get started!</p>","text":""},{"location":"02_docker/#docker-container","title":"Docker container  <p>A docker container is a sandboxed process running on a host machine that is isolated from all other processes running on that host machine.</p>","text":""},{"location":"02_docker/#docker-image","title":"Docker image  <p>A running container uses an isolated filesystem. This isolated filesystem is provided by an image, and the image must contain everything needed to run an application:</p> <ul> <li>dependencies, </li> <li>configurations, </li> <li>scripts, </li> <li>binaries, </li> <li>etc. </li> </ul> <p>The image also contains other configurations for the container, such as </p> <ul> <li>environment variables, </li> <li>a default command to run, </li> <li>other metadata.</li> </ul>","text":""},{"location":"02_docker/#container-properties","title":"Container properties  <p>A container </p> <ul> <li>Is a runnable instance of an image. You can create, start, stop, move, or delete a container using the Docker API or CLI.</li> <li>Can be run on local machines, virtual machines, or deployed to the cloud.</li> <li>Is portable (and can be run on any OS).</li> <li>Is isolated from other containers and runs its own software, binaries, configurations, etc.</li> </ul>","text":""},{"location":"02_docker/#docker-hub","title":"Docker Hub  <p>Docker Hub is the world's largest library and community for container images ( https://hub.docker.com/ ).</p>    <p>You can directly get official docker images or computed by the community.</p>","text":""},{"location":"02_docker/#hello-world-and-docker-basic-commands","title":"Hello world and docker basic commands","text":""},{"location":"02_docker/#docker-pull","title":"Docker pull <p>This command is used to download a docker image from a registry, such as Docker Hub, to your local system.</p> <p>You can try to run the following command to pull your first docker image:</p> <pre><code>docker pull hello-world\n</code></pre> <p>You can now try to pull another image which will be used later in this workshop session: a postgresql (version 17) database with postgis extension (version 3.5).</p> <pre><code>docker pull postgis/postgis:17-3.5\n</code></pre> <p>To prepare for the Workshop, you can also already pull the Imposm image:</p> <pre><code>docker pull geopostcodes/imposm:1.2\n</code></pre>","text":""},{"location":"02_docker/#docker-ps","title":"Docker ps <p>This command shows the list of currently running containers along with their details, such as container ID, names, and status.</p> <pre><code>docker ps\n</code></pre> <p>If you add the <code>--all</code> parameter, you will also see stopped containers:</p> <pre><code>docker ps --all\n</code></pre>","text":""},{"location":"02_docker/#docker-run","title":"Docker run <p>This command__creates and runs a new Docker container__ based on a specified image. It can also be used to specify various options and settings for the container.</p> <p>If you try now to instanciate the hello-world image previously pulled:</p> <pre><code>docker run hello-world\n</code></pre> <p>You should see some kind words (coming from docker team) in the container logs! ;-)</p> <p>If you check the list of active containers, you will discover that docker assign a random (fancy) name to your container. To avoid this and easily keep track of your docker containers, you can add a <code>--name</code> parameter.</p> <p>Here is another docker run example related to our workshop: a postgis container with a custom setup:</p> <pre><code>docker run --name postgis_sotm -p 5482:5432 -e POSTGRES_PASSWORD=postgres -d postgis/postgis:17-3.5\n</code></pre> <p>You can see that we specify a particular name for the container (postgis_sotm), handle the port forwarding, set environement variables (postgres database user password), run in background (-d), version of Postgresql (17) and finally the version of Postgis (3.5).</p> <p>Everything in 1 single command and deployed in only few seconds! Impressive, isn't it?!</p>","text":""},{"location":"02_docker/#docker-start","title":"Docker start <p>This command is used to start one or more stopped containers, allowing them to run in the background.</p> <p>If your postgis_sotm container is not running (TIP: check it with <code>docker ps</code> command), you can start it with the following command:</p> <pre><code>docker start postgis_sotm \n</code></pre>","text":""},{"location":"02_docker/#docker-stop","title":"Docker stop <p>This command is used to stop one or more running containers, pausing their execution.</p> <p>If your postgis_sotm container is running (TIP: check it with <code>docker ps</code> command), you can stop it with the following command:</p> <pre><code>docker stop postgis_sotm \n</code></pre>","text":""},{"location":"02_docker/#docker-rm","title":"Docker rm <p>This command removes one or more stopped containers from your system. Containers must be stopped before they can be removed.</p> <pre><code>docker rm postgis_sotm\n</code></pre> <pre><code>If you removed your postgis_sotm with the previous command, don't forget to recreate it for the next exercices! ;-) \n</code></pre>","text":""},{"location":"02_docker/#docker-exec","title":"Docker exec <p>This command allows you to run a command inside a running container. It provides a way to execute commands in an already running container without the need to start a new shell session.</p> <p>If we want to access a bash terminal in the previous postgis container, we can run:</p> <pre><code>docker exec -it postgis_sotm bash\n</code></pre>","text":""},{"location":"02_docker/#bonus-dockerfile","title":"BONUS: Dockerfile  <p>We won't be using dockerfiles during this workshop, just pre-built images available on the Docker Hub. This section is here for your information. <p>A Dockerfile is a text-based file with no file extention that contains a script of instructions. Docker uses this script to build a container image.</p> <p>Here is an example of Dockerfile for an imposm image (built by GeoPostcodes team)</p> <pre><code># docker build --platform linux/amd64,linux/arm64 -t geopostcodes/imposm:1 --push .\nFROM debian:latest\n\n# don't use root as the running user\nRUN groupadd -g 999 imposm &amp;&amp; \\\n    useradd -r -u 999 -g imposm imposm\n\n# Install base utilities\nRUN apt-get update &amp;&amp; \\\n    apt-get install -y wget &amp;&amp; \\\n    apt-get install -y tar gzip &amp;&amp; \\\n    apt-get clean &amp;&amp; \\\n    rm -rf /var/lib/apt/lists/*\n\n# install imposm\nUSER 999\nWORKDIR /usr/app\nRUN wget --quiet https://github.com/omniscale/imposm3/releases/download/v0.11.1/imposm-0.11.1-linux-x86-64.tar.gz &amp;&amp; \\\n    tar -xf imposm-0.11.1-linux-x86-64.tar.gz &amp;&amp; \\\n    mv ./imposm-0.11.1-linux-x86-64/* . &amp;&amp; \\\n    rm -rf ./imposm-0.11.1-linux-x86-64 &amp;&amp; \\\n    rm imposm-0.11.1-linux-x86-64.tar.gz\n\n</code></pre> <p>You can see that a Dockerfile is composed of adapted linux commands such as <code>groupadd</code>, <code>wget</code>, <code>apt-get</code>, <code>rm</code> etc. to prepare the image based on a linux dockerized OS such as Debian, Alpine or Ubuntu for example.</p> <p>To build an image from a Dockerfile and with a tag, you can run a command similar to the following in your Dockerfile folder location:</p> <pre><code>docker build -t my-image-tag .\n</code></pre>","text":""},{"location":"02_docker/#docker-volumes","title":"Docker Volumes  <p>A Docker volume is a persistent data storage mechanism that allows containers to store and share data independently from the container lifecycle. Volumes provide a way to persist data even if the container that created them no longer exists. They are used to store files, databases, or any other type of data that containers need to read from or write to during their lifetime. </p> <p>By using volumes, developers can separate the concerns of storage from the application logic, making it easier to maintain, update, and scale containerized applications without losing critical data when containers are removed or replaced.</p>","text":""},{"location":"02_docker/#docker-compose","title":"Docker Compose  <p>A <code>docker-compose.yml</code> file is a configuration file used to define and manage multi-container Docker applications. It allows you to specify the services, networks, and volumes required for your application in a declarative manner. In a docker-compose file, you can define multiple services, each representing a containerized application component. These services can be configured with various options, including Docker images, environment variables, ports, volumes, and dependencies. By using a docker-compose file, you can define the entire application stack, its relationships, and configurations in one centralized place. </p> <p>When you run docker-compose up, Docker Compose reads the configuration from the file and starts the specified services, creating the necessary containers, networks, and volumes based on the defined configurations. This simplifies the process of managing complex applications by enabling you to launch and scale multi-container setups with a single command, making it easier to develop, test, and deploy applications in different environments.</p> <p>In your <code>docker-compose.yml</code> folder location, you can deploy it by running the following command:</p> <pre><code>docker-compose up\n</code></pre> <p>If you want to remove the previous containers version before starting a new setup, you can use the <code>docker-compose down</code> command. This command stops and removes the containers defined in your <code>docker-compose.yml</code> file:</p> <pre><code>docker-compose down\n</code></pre>","text":""},{"location":"03_postgis/","title":"Postgis","text":""},{"location":"03_postgis/#storing-geographic-data-in-postgresql-postgis-to-the-rescue","title":"Storing geographic data in Postgresql: Postgis to the rescue!  <p>PostGIS is an open-source geospatial extension for PostgreSQL, a popular relational database management system (RDBMS).  It enhances PostgreSQL by adding support for geographic objects, allowing the storage, retrieval, and analysis of geospatial data.</p> <p>PostGIS enables the database to handle various geospatial data types such as points, lines, polygons, and geographic features with associated attributes. It provides a wide range of spatial functions and operators, enabling complex geospatial operations like spatial joins, buffering, and geometric calculations. </p> <p>PostGIS is powerful because it allows users to store and manage large volumes of geospatial data efficiently, perform spatial queries for mapping applications, conduct spatial analysis, and support geographic information system (GIS) functionalities within a database environment. Its ability to handle spatial indexing and advanced spatial analysis makes it a valuable tool for applications dealing with geospatial data.</p> <p></p> <p>PostGIS includes an optimized spatial indexing system ensures high performance even with a significant volume of data, which is essential for some applications. This is the case for the usage targeted in this Workshop, as obviously OpenStreetMap represents a massive amount of data!</p> <p>Lastly, the choice of PostGIS is reinforced by its open source nature and active community. The PostGIS community provides regular updates, security patches, and comprehensive documentation, making it a reliable choice for storing and querying medium to large-scale OpenStreetMap datasets.</p>","text":""},{"location":"03_postgis/#postgis-docker-container","title":"Postgis docker container  <p>Now that you know both Docker and Postgis, it is time to use them!</p> <p>To directly create a Postgresql 17 database including Postgis extention (version 3.5), you can run the following command:</p> <pre><code>docker run \\\n    --name postgis_sotm \\\n    -p 5482:5432 \\\n    -e POSTGRES_PASSWORD=postgres \\\n    -d postgis/postgis:17-3.5\n</code></pre> <pre><code>WARNING: if you are using Mac OS, you can have troubles with this image because it doesn't support ARM64 architecture. To avoid it, you can use another (non official) postgis image and replace the last line by:\n-d imresamu/postgis:latest\n</code></pre> <p>Note that this command includes some parameters:</p> <ul> <li> <p><code>--name postgis_sotm</code> specify the name of your new docker container as \"postgis_sotm\"</p> </li> <li> <p><code>-p 5482:5432</code> setup the port forwarding. The first port number corresponds to your host port and the second port number corresponds to your container port. They are different to avoid a possible conflict with an existing Postgresql installation on your device.</p> <ul> <li>Host port number: to avoid conflicts with an existing PostgreSQL installation running on port 5432 (the default port for PostgreSQL) we change this parameter using <code>-p 5482:5432</code> to setup your container on host port number 5482.</li> <li>Container port number: 5432 is the default port of PostgreSQL and you need to expose it to be able to access the database in your container. You can keep this value even if you have another PostgreSQL installation or container.</li> </ul> </li> <li> <p><code>-e POSTGRES_PASSWORD=postgres</code> specify the password for admin user postgres. In this workshop we will only setup a sandbox to play with PostGIS and use postgres/postgres as credentials. If you consider using this container for another purpose please change this setup.</p> </li> <li> <p><code>-d postgis/postgis:17-3.5</code> specify the docker image from dockerhub we use. Here we use the official PostGIS image ( https://hub.docker.com/r/postgis/postgis) based on postgres image and in a specific version: Postgresql 17 + Postgis 3.5.</p> </li> </ul> <p>Once your container is running, you can see it in the active container list in Docker Desktop interface or by using the following docker command:</p> <pre><code>docker ps\n</code></pre>","text":""},{"location":"03_postgis/#interacting-with-postgis-sql-client","title":"Interacting with Postgis: SQL client  <p>To interact with your database, I recommend 3 differents applications with GUI and embedded SQL editor: DBeaver, pgAdmin or QGIS. To go through this workshop, you will need at least one of them. You could also run SQL command in psql command line tool but it is less user friendly in this learning context. </p>","text":""},{"location":"03_postgis/#dbeaver-community-edition-ce","title":"DBeaver community edition (CE)  <p>DBeaver Community is a free cross-platform database tool for developers, database administrators, analysts, and everyone working with data. It supports all popular SQL databases like MySQL, MariaDB, PostgreSQL, SQLite, Apache Family, and more.</p>  <p>DBeaver community edition is the software I recommend to run SQL queries during this workshop. To install it, you can follow the instructions on their official website: https://dbeaver.io/download/</p> <p>To create your first PostgreSQL connexion you can follow the documentation: https://dbeaver.com/2022/03/03/how-to-create-database-connection-in-dbeaver/.  Note that DBeaver will automatically download and install PostgreSQL driver when you will create your first PostgreSQL connexion. </p> <p>If you followed the previous docker configuration (user, password, port number), you can use the following connection setup:</p> <p></p>","text":""},{"location":"03_postgis/#pgadmin","title":"pgAdmin <p>If you prefer the official PostgreSQL client and interface, you can also install and use pgAdmin: https://www.pgadmin.org/download/</p>  <p>pgAdmin is the most popular and feature rich Open Source administration and development platform for PostgreSQL, the most advanced Open Source database in the world. </p>  <p>If you followed the previous docker configuration (user, password, port number), you can create a new server connection (object &gt; register &gt; server) and use the following connection setup:</p> <p></p>","text":""},{"location":"03_postgis/#qgis","title":"QGIS  <p>A Free and Open Source Geographic Information System </p>  <p>QGIS software is able to interact with a Postgis database and run SQL queries through its powerfull DB Manager plugin. </p> <p>To install QGIS, please follow official documentation: https://www.qgis.org/en/site/forusers/download.html</p> <p>To add the connection to your local postgis database: right click on \"Postgresql\" in the \"Browser\" left menu &gt; new connection and use the following setup: </p> <p></p>","text":""},{"location":"04_imposm/","title":"Imposm  <p>Official website: https://imposm.org/docs/imposm3/latest//</p>  <p>Imposm is a command-line Extract Transform and Load (ETL) tool used for importing OpenStreetMap (OSM) data into PostGIS databases efficiently. It is specifically designed to handle large-scale geospatial datasets. Imposm performs tasks such as data filtering, simplification, and schema mapping, ensuring that the data is structured appropriately for storage in a PostGIS-enabled PostgreSQL database. Imposm's command-line interface allows users to customize the import process according to their specific requirements, making it a valuable tool for efficiently importing and managing vast volumes of OSM data for geospatial applications.</p> <p></p>","text":""},{"location":"04_imposm/#what-about-other-osm-data-import-tools","title":"What about other OSM data import tools? <p>In our context, Imposm stands out as the ideal choice for importing OpenStreetMap (OSM) data into PostGIS based on several key advantages when compared to its competitors:</p> <ul> <li>Overpass API: Imposm has a simpler syntax, avoids timeout issues and network dependency. </li> <li>Pyrosm: Imposm is optimized for importing large OSM datasets into databases, while Pyrosm loads data into memory, making it suitable for small datasets but impractical for larger ones. </li> <li>In contrast to Osm2pgsql, Imposm offers built-in support for parallel processing, allowing for faster imports, and provides a flexible mapping schema that can be customized according to specific needs. While Osm2pgsql lacks support for incremental updates, Imposm enables the incorporation of changes over time. </li> </ul> <p>Moreover, Imposm allows for the utilization of Spatial SQL, enabling powerful spatial queries and analysis within the PostGIS environment, providing a comprehensive and efficient solution for handling OSM data at scale.</p> <p></p>","text":""},{"location":"04_imposm/#folder-structure","title":"Folder structure <p>To run the following steps, it is recommended to follow the same structure.</p> <p>If you cloned or downloaded the github repository (https://github.com/jerome-urbain/SotMUS25), check that you have the following structure especially for the <code>imposm</code> folder:</p> <pre><code>.\n\u2514\u2500\u2500 sotm_workshop/\n    \u251c\u2500\u2500 imposm/\n    \u2502   \u251c\u2500\u2500 docker-compose.yml\n    \u2502   \u251c\u2500\u2500 mapping/\n    \u2502   \u2502   \u2514\u2500\u2500 mapping.yml\n    \u2502   \u2514\u2500\u2500 osm_data/\n    \u2502       \u2514\u2500\u2500 XX.osm.pbf\n    \u251c\u2500\u2500 docs\n        \u2514\u2500\u2500figures\n    \u251c\u2500\u2500 docker\n    \u2514\u2500\u2500 slides\n</code></pre> <p>If the <code>osm_data</code> folder is missing, create it (empty). osm.pbf files will be downloaded in the next section.</p>","text":""},{"location":"04_imposm/#download-data","title":"Download data <p>You can download data in osm.pbf format directly from geofabrik website (http://download.geofabrik.de/). I suggest to start with a small country or state in the following list:</p> <ul> <li>Andorra: http://download.geofabrik.de/europe/andorra-latest.osm.pbf</li> <li>Luxembourg: http://download.geofabrik.de/europe/luxembourg-latest.osm.pbf</li> <li>South Dakota: https://download.geofabrik.de/north-america/us/south-dakota-latest.osm.pbf</li> </ul> <p>To use the setup defined in this workshop, it is recommended to save these files in the <code>imposm/osm_data</code> folder such as described in the previous section. If this folder doesn't exist yet, create it.","text":""},{"location":"04_imposm/#filter-data-during-the-import-with-a-mapping-file","title":"Filter data during the import with a mapping file <p>When importing OSM data into PostGIS with Imposm, the <code>mapping.yml</code> file plays a crucial role. It is used to define the mapping between OSM data elements (nodes, ways, and relations) and the database schema in PostGIS.  Imposm uses this mapping file to determine how OSM data should be stored and organized within the PostGIS database. </p> <p>This configuration file contains rules about:</p> <ul> <li> <p>Data Transformation: The <code>mapping.yml</code> file defines how OSM tags are transformed into database columns. Each OSM tag can be mapped to a specific column in one or more database tables. For example, OSM tags like \"highway\" or \"name\" can be mapped to corresponding columns in the database schema.</p> </li> <li> <p>Schema Definition: It defines the structure of the PostGIS database schema. For instance, it specifies which tables should be created for nodes, ways, and relations, and what columns these tables should contain. The file also defines the data types for each column (e.g., text, integer, geometry).</p> </li> <li> <p>Geometry Types and Coordinates: For spatial data like points, lines, and polygons, the <code>mapping.yml</code> file specifies how OSM node coordinates are transformed into geometries. It defines the geometry type (Point, LineString, Polygon) and the coordinate columns (usually \"lon\" and \"lat\" for longitude and latitude).</p> </li> <li> <p>Relations: OSM data often contains relationships between elements. The <code>mapping.yml</code> file defines how these relations should be represented in the database, allowing for the creation of tables to store these relationships.</p> </li> <li> <p>Advanced Mapping: The file supports more advanced configurations, such as applying filters based on OSM tags, conditional mapping (mapping certain tags only if certain conditions are met), and handling complex geometries.</p> </li> </ul> <p>By providing a clear and customizable mapping between OSM data and the database schema, the <code>mapping.yml</code> file allows Imposm to accurately import OSM data into PostGIS, ensuring that the data is properly structured, organized, and ready for spatial queries and analysis within the PostgreSQL database.</p> <p>Here is a simple mapping file directly inspired by the official imposm3 documentation (https://imposm.org/docs/imposm3/latest/mapping.html). This configuration allows to creates a <code>road</code> table in PostGIS to store linear geometries (linestring) related to any OSM data tagged as <code>highway</code> (of any type).</p> <pre><code>tables:\n  road:\n    type: linestring\n    mapping:\n      highway: [__any__]\n      #highway: [path, track, unclassified]\n    columns:\n    - {name: osm_id, type: id}\n    - {name: geom, type: geometry}\n    - {key: name, name: street_name, type: string}\n    - {key: bridge, name: is_bridge, type: bool}\n    - {name: highway_type, type: mapping_value}\n</code></pre> <p>Note that some mapping rules are applied on attributes to define the columns of the <code>road</code> table:</p> <ul> <li>a column named <code>osm_id</code> of type ID is created to store the unique identifier of the OSM element.</li> <li>a column named <code>geom</code> of type geometry is created to store the LineString geometries.</li> <li>a <code>street_name</code> column of type string is created and mapped from the OSM tag with key <code>name</code>. This allows storing street names.</li> <li>a column named <code>is_bridge</code> of type boolean is created and mapped from the OSM tag with key <code>bridge</code> to indicate whether the road is a bridge or not.</li> <li>a column named <code>highway_type</code> of a custom type mapping_value is created to stores the specific values of the <code>highway</code> tag (path, track, unclassified, etc.).</li> </ul> <p>You can also see that there is a commented line to show you what would be this line for specific highway types such as path, track and unclassified. If you want to use this filter on highway types you can replace the previous line (containing <code>__any__</code>) with it.</p> <p>Note that an OSM element is only inserted once even if a mapping matches multiple tags.</p>","text":""},{"location":"04_imposm/#imposm-docker-image","title":"Imposm docker image <p>To skip the imposm installation only available on linux, you can directly pull an existing imposm docker image released by the GeoPostcodes team:</p> <pre><code>docker pull geopostcodes/imposm:1.2\n</code></pre> <p>With this docker image you have a ready to use imposm setup in only few seconds! It's pretty cool, isn't it?</p> <pre><code>IMPORTANT NOTE:\nIf we instantiate this image and create a container based on it, the container will not be able to communicate with the postgis container we created before because they are isolated by default (container principle). They would not be in the same network. \nIn consequence, they cannot communicate together and you cannot reach postgis container from the imposm one, which makes OSM data import impossible based on this setup. Be patient, we will solve this issue in the next section!\n</code></pre>","text":""},{"location":"05_postgis_imposm/","title":"Postgis + imposm docker stack <p>To enable the Postgis container and the Imposm container to communicate with each other, we're going to place them in the same docker stack, created from a <code>docker-compose.yml</code> file.</p> <p>In a Docker Compose setup, when containers are defined within the same service stack, they share the same network namespace by default.  This means they can communicate with each other using their service names as hostnames.  For example, if we include services named <code>imposm</code> and <code>postgis</code> in a <code>docker-compose.yml</code> file, the imposm service can connect to the postgis db service using the hostname \"postgis\". This visibility between containers in the same stack simplifies inter-container communication, making it easier for services within the same application stack to interact with each other seamlessly.</p> <p>To combine Postgis and Imposm in a stack, you can save the following <code>docker-compose.yml</code> file:</p> <pre><code>version: '3.8'\n\nservices:\n\n  postgis_osm:\n    image: postgis/postgis:17-3.5\n    ports: \n      - \"5482:5432\"\n    environment:\n      - POSTGRES_PASSWORD=postgres\n\n  imposm:\n    image: geopostcodes/imposm:1.2\n    stdin_open: true  # Equivalent to -i\n    tty: true         # Equivalent to -t\n    volumes:\n        - ./osm_data/:/osm_data   \n        - ./mapping/:/mapping\n    depends_on:\n        - postgis_osm\n    deploy: \n        restart_policy:\n            condition: on-failure\n            delay: 3s\n            max_attempts: 5\n            window: 5s\n</code></pre> <p>and, in the folder where you stored it, run the following docker command:</p> <pre><code>docker-compose up\n</code></pre> <p>We now have the following infrastructure: </p> <pre><code>IMPORTANT NOTE:\nAs the 2 containers are in the same stack and have simplified inter-container communication, you can use the port 5432 (and not 5482) and the service names 'postgis_osm' as hostname when you want to reach postgis database from imposm container.\n</code></pre> <p>You can now enter the container bash terminal by typing the following command:</p> <pre><code>docker exec -it imposm-imposm-1 bash\n</code></pre> <p>We will run some commandline from this terminal, you can keep it open for now!</p>","text":""},{"location":"05_postgis_imposm/#import-osm-data-from-an-osmpbf-file-based-on-mapping-rules","title":"Import OSM data from an osm.pbf file based on mapping rules <p>By default an OSM data import process using Imposm is divided in 2 steps: 1. Reading step 2. Writing step</p>","text":""},{"location":"05_postgis_imposm/#reading","title":"Reading  <p>Building the way and relation geometries requires random access to all nodes and ways, but this is not supported by the OSM PBF data format. Imposm needs to store all nodes, ways and relations in an intermediary data store that allows random access to these elements. It does this on-disk to keep the memory usage of Imposm low. Having lots of memory will still speed the import up, because your OS will use all free memory for caching of these files. Imposm uses LevelDB key-value databases for this, which are fast and compact. Source: https://imposm.org/docs/imposm3/latest/tutorial.html</p>  <p>Imposm needs to know which OSM elements you want to have in your database. You can use the provided mapping.yml file for this tutorial, but you should read Data Mapping for more information on how to define your own mapping.</p> <p>Example: to reading Andorra OSM data based on a <code>mapping.yml</code> file, You can run the following command from the terminal inside the Imposm docker container:</p> <pre><code># if you are not running a terminal session in the imposm container, run also the next line:\n# docker exec -it imposm-imposm-1 bash\n/usr/app/imposm import -mapping /mapping/mapping.yml -read /osm_data/andorra-latest.osm.pbf\n</code></pre> <p>We can see that a <code>-read</code> parameter is used in the command and the <code>mapping.yml</code> is used to load the mapping rules between OSM files and Postgresql database.</p>","text":""},{"location":"05_postgis_imposm/#writing","title":"Writing  <p>The second step is the writing of OpenStreetMap features into the database. It reads the features from the cache from step one, builds all geometries and imports them into the according tables. By default it overwrites existing tables. Source: https://imposm.org/docs/imposm3/latest/tutorial.html</p>  <p>Example: write data already cached in a Postgis database and specify the destionation database (postgres):</p> <pre><code># docker exec -it imposm-imposm-1 bash\n/usr/app/imposm import -mapping /mapping/mapping.yml -write -dbschema-import osm -connection postgis://postgres:postgres@postgis_sotm:5432/postgres\n</code></pre> <p>We can see this time that a <code>-write</code> parameter is used in the command and we need to specify the connection string to access the Postgis database. In addition, a <code>-dbschema-import</code> parameter is used to specify the database schema (osm).</p>","text":""},{"location":"05_postgis_imposm/#combine-reading-and-writing","title":"Combine reading and writing <p>It is also possible to combine reading and writing in one single step:</p> <pre><code># docker exec -it imposm-imposm-1 bash\n/usr/app/imposm import -mapping /mapping/mapping.yml -read /osm_data/andorra-latest.osm.pbf -write -connection postgis://postgres:postgres@postgis_sotm:5432/postgres\n</code></pre> <p>Both <code>-read</code> and <code>-write</code> parameters are use in this configuration.</p> <p>If we want to add more parameters to customize the import, we can for example ask for overwriting the cached data during the import, specify the destination database schema and specify the port number:</p> <pre><code>/usr/app/imposm import -mapping /mapping/mapping.yml -read /osm_data/andorra-latest.osm.pbf -write -overwritecache -dbschema-import osm -connection postgis://postgres:postgres@postgis_sotm:5432/postgres\n</code></pre> <pre><code>__Note:__ now that you did your first import with success, feel free to change mapping rules, import parameters and ingest bigger countries to get an overview of Imposm capabilities!\n</code></pre>","text":""},{"location":"06_interact_with_data/","title":"Query data stored in Postgis <p>Depending on your setup, you can browse or query the OSM data which are now stored in Postgis.</p> <p>It is now time to take advantage of having the data in Postgresql database!</p>","text":""},{"location":"06_interact_with_data/#read-table-with-qgis","title":"Read table with QGIS <pre><code>NOTE:\nDue to the different possible setups tested during the preparation of this workshop, layers/tables/attributes name can differ between the screenshots and what you have on your laptop but the procedure is similar.\n</code></pre> <p>If you want to read your data stored in Postgis, you can use the following steps in QGIS menus:</p> <p>Database menu &gt; DB Manager &gt; Postgis &gt; [Your_connection_name] &gt; [osm_schema_name] &gt; [osm_table_table] &gt; Right click on [osm_table_table] &gt; Add to canvas</p> <p></p> <p>Your data should now be loaded as a vector layer into QGIS map canvas: </p> <p>Feel free now to add an OpenStreetMap XYZ tiles basemap and play with the properties of the layer! Why not applying a categorized symbology based on the highway_type attribute for example?</p>","text":""},{"location":"06_interact_with_data/#browse-and-query-table-in-dbeaver","title":"Browse and query table in DBeaver  <pre><code>By default these data are stored in \"Web Mercator\" coordinates system (EPSG 3857).\nAll the measures are then based on the \"mercator meter\" unit. If you want more accurate results, don't hesitate to transform the data in a more adequate/relevant projection considering your interest area.\n</code></pre>","text":""},{"location":"06_interact_with_data/#query-1-10-longuest-roads","title":"Query 1: 10 longuest roads <pre><code>-- top 10 longest roads:\nselect  round(ST_Length(r.geom)) length, r.*\nfrom osm.osm_road r\norder by ST_Length(r.geom) desc \nlimit 10\n</code></pre>","text":""},{"location":"06_interact_with_data/#query-2-number-of-roads-per-type","title":"Query 2: number of roads per type <pre><code>select count(*), highway_type \nfrom osm.osm_road r\ngroup by highway_type\norder by 1 desc;\n</code></pre> <p>If you are interested by the proportion of each highway type (based on the number of roads, not their lenght!), you can compute the percentages per type:</p> <pre><code>with total as ( select count(*) nb from osm.osm_road r )\nselect \n    count(r.*) as nb_road, \n    round(100 * count(r.*)::numeric / t.nb::numeric, 2) as percentage, \n    r.highway_type \nfrom osm.osm_road r, total t\ngroup by r.highway_type, t.nb\norder by 1 desc; \n</code></pre>","text":""},{"location":"06_interact_with_data/#query-3-km-of-roads-per-type","title":"Query 3: km of roads per type <pre><code>select r.highway_type, sum(ST_Length(r.geom)) / 1000 as km\nfrom osm.osm_road r\ngroup by r.highway_type\norder by 2 desc;\n</code></pre>","text":""},{"location":"06_interact_with_data/#going-further","title":"Going further <p>This workshop is limited to these basic queries but don't hesitate to add other geospatial data and modify the current setup to run spatial queries between layers.</p> <p>Some examples:  - add a municipalities table and compute the number of pedestrian road/tracks per municipality - evaluate the connectivity between municipalities by extracting the roads connecting them and build a graph of it - identify uncomplete OSM features in your area to plan your next contribution - ...</p>","text":""},{"location":"06_interact_with_data/#homework-exercise","title":"Homework exercise <p>Can you compute the number of buildings within each Zip code are in Massachusetts?</p> <p>Adapt the code we've developed so far to:</p> <ol> <li>Import the Massachusetts data from OSM (https://download.geofabrik.de/north-america/us/massachusetts.html)</li> <li>Upload the buildings from OSM instead of the roads (mapping.yml)</li> <li>Download the ZCTA shapefiles: https://www.census.gov/cgi-bin/geo/shapefiles/index.php?year=2020&amp;layergroup=ZIP%20Code%20Tabulation%20Areas</li> <li>Import the ZCTA polygons within your PostGIS database. Several options here<ul> <li>import them from QGIS</li> <li>better: create another docker container including the shp2pgsql utility</li> <li>alternative: add shp2pgsql to your PostGIS container</li> </ul> </li> <li>Write a query to count the number of buildings within each Zip code area</li> <li>Follow-up: categorize building types (residential, commercial, industrial, ...) and count the proportion of each type per zip code area</li> </ol>","text":""},{"location":"07_docker_stack/","title":"Docker stack","text":""},{"location":"07_docker_stack/#automated-docker-stack","title":"Automated docker stack  <p>If you want to go further in your deployment, you can directly add the imposm import command at the end of the <code>docker-compose.yml</code> file: at the end of the stack deployment, docker will also launch the import:</p> <pre><code>version: '3.8'\n\nservices:\n\n  postgis_sotm:\n    image: postgis/postgis:17-3.5\n    ports: \n      - \"5482:5432\"\n    environment:\n      - POSTGRES_PASSWORD=postgres\n\n  imposm:\n    image: geopostcodes/imposm:1.2\n    volumes:\n        - ./osm_data/:/osm_data   \n        - ./mapping/:/mapping\n    depends_on:\n        - postgis_osm\n    deploy: \n        restart_policy:\n            condition: on-failure\n            delay: 3s\n            max_attempts: 5\n            window: 5s\n    command:  \n      /usr/app/imposm import -mapping /mapping/mapping.yml -read /osm_data/andorra-latest.osm.pbf -write -overwritecache -dbschema-import osm -connection postgis://postgres:postgres@postgis_sotm:5432/postgres\n</code></pre> <p>Don't forget to launch a <code>docker-compose down</code> command if you want to replace a previous setup.</p>","text":""},{"location":"08_conclusion/","title":"Conclusion <p>This workshop showed that, despite a learning curve, docker can be a great help in ingesting OpenStreetMap data into a Postgis database using imposm. Here are a few takeaways:</p> <ul> <li> <p>Efficient ETL with Imposm: Imposm's integration with Docker simplifies the Extract, Transform, Load (ETL) process for OpenStreetMap data, enhancing efficiency in importing large-scale OpenStreetMap datasets into PostGIS databases.</p> </li> <li> <p>Portability and Consistency: Dockerizing the stack ensures a consistent environment across different systems, eliminating compatibility issues and simplifying the setup process.</p> </li> <li> <p>Modularity and Scalability: The modular nature of Docker containers allows for the isolation of services, promoting scalability and easy deployment of specific components as needed.</p> </li> <li> <p>Streamlined Development Workflow: The encapsulation of dependencies within Docker containers streamlines the development workflow, providing a standardized environment for both development and production.</p> </li> <li> <p>Enhanced Collaboration: Docker's containerization facilitates collaboration by enabling developers to share consistent development environments, reducing the \"it works on my machine\" problem.</p> </li> <li> <p>Dependency Management: Dockerized stacks make dependency management more manageable, ensuring that the necessary software versions and configurations are uniform across different stages of development and deployment.</p> </li> <li> <p>Future Scalability: The Dockerized approach provides a foundation for future scalability, making it easier to adapt the stack to evolving project requirements and increasing data volumes.</p> </li> <li> <p>Simplified Operations: Managing and maintaining the data workflow becomes more straightforward with Docker, allowing for efficient updates, easy rollbacks, and simplified operations.</p> </li> </ul>","text":""}]}